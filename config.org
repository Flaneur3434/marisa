#+STARTUP: overview
#+TITLE: Marisa
#+LANGUAGE: en
#+OPTIONS: num:nil
Emacs - Connect To The Wired Edition

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

[[./athos_monk_emacs.png]]
* Introduction
Based off of Witchmacs(https://github.com/snackon/Witchmacs)
How to download
#+BEGIN_SRC bash
  git clone https://github.com/GrapeJuiceSoda/marisa .emacs.d
  cd .emacs.d
  git submodule update --init
  ./update-git-packages.sh --init
  ./update-git-packages.sh --update
  # you may need to run package-refresh-contents in emacs also
#+END_SRC
* Why would I use this?
#+BEGIN_QUOTE
A very basic config (KISS!)
#+END_QUOTE
I used Witchmacs because as opposed to many other Emacs distributions, Witchmacs has ZERO customization layers which means you can just jump in, look at the config file and start editing away!
After all, Emacs works best when it's customized to your own liking!
* Dependencies
=clang= as backend for C and C++ autocompletion

=llvm= to install irony server

(optional) =mvn= maven for java project handling through =meghanada=
* QoL section
Minor quality-of-life modifications for a more pleasant Emacs experience
** Enable line numbers
*** Use relative line number
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC
*** Emacs breaks certain modes when it has line-numbers-mode enabled, (like docview
or ansi-term) so I utilize the approach of only enabling it on some major modes
rather than globally
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
                              (progn
                                (display-line-numbers-mode)
                                (setq display-line-numbers t))))
  (add-hook 'text-mode-hook (lambda ()
                              (progn
                                (display-line-numbers-mode)
                                (setq display-line-numbers t))))
#+END_SRC
*** Use absolute line numbers even when buffer is narrowed.
#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'display-line-numbers-widen t)
#+END_SRC
** Show parent parentheses
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Disable the default startup screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
** Disable most gui elements
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (blink-cursor-mode 0)
  ;; enable pulsing animations
  (setq pulse-flag t)
#+END_SRC
** Enable copypasting outside of Emacs
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t)
  ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
  ;; Selecting sets primary clipboard.
  (setq select-enable-primary t)
#+END_SRC
** Disable automatic creation of backup files
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC
** Enable smooth scrolling and inplace scrolling
scrolling
#+BEGIN_SRC emacs-lisp
  ;; Cut down on the number of line scans emacs does
  (setq bidi-paragraph-direction 'left-to-right
        bidi-inhibit-bpa t)
  ;; Fully redraw the display before it processes queued input events.
  (setq redisplay-dont-pause t)
  ;; The text on the screen should always be fontified, no delay
  (setq jit-lock-defer-time 0)
  ;; Number of lines of continuity to retain when scrolling by full screens
  (setq next-screen-context-lines 2)
  ;; only 'jump' when moving this far off the screen
  (setq scroll-conservatively 10000)
  ;; Keyboard scroll one line at a time
  (setq scroll-step 1
        mouse-wheel-follow-mouse t
        mouse-wheel-progressive-speed nil)
  ;; Don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
  ;; Scroll window under mouse
  (setq mouse-wheel-follow-mouse t)
  ;; No (less) lag while scrolling lots.
  (setq fast-but-imprecise-scrolling t)
  ;; Cursor move faster
  (setq auto-window-vscroll nil)

  ;; pixel scroll settings
  (setq-default scroll-conservatively 10000)
  (setq-default scroll-margin 5)

  (pixel-scroll-precision-mode t)
  ;; (setq pixel-scroll-precision-use-momentum t)
  ;; (setq pixel-scroll-precision-interpolate-mice t)
  ;; (setq pixel-scroll-precision-large-scroll-height 10.0)
  ;; (setq pixel-scroll-precision-interpolate-page t)
  (global-set-key [next] #'pixel-interpolate-up)
  (global-set-key [prior] #'pixel-interpolate-down)


  ;; (good-scroll-mode 1)
  ;; (setq good-scroll-step 103)
  ;; (setq good-scroll-render-rate 0.02)

  ;; (global-set-key [next] #'good-scroll-up-full-screen)
  ;; (global-set-key [prior] #'good-scroll-down-full-screen)
#+END_SRC
** Disable ring-bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
** Indentation
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
  (setq-default standard-indent 4)
  (setq c-basic-offset tab-width)
  (setq-default electric-indent-inhibit t)
  (setq-default indent-tabs-mode t)
  (setq backward-delete-char-untabify-method 'nil)
#+END_SRC
** Save position
#+BEGIN_SRC emacs-lisp
  (save-place-mode 1)
#+END_SRC
** Paragraph Filling
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC
** Enable prettify symbols mode
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode -1)
#+END_SRC
** Enable bracket pair-matching
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '(
                              (?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")
                              ))
  (electric-pair-mode t)
#+END_SRC
** Transform yes-or-no questions into y-or-n
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Highlight current line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC
** Highlight TODO and ERROR
#+BEGIN_SRC emacs-lisp
  ;; Bright-red TODOs
  (setq fixme-modes '(c++-mode c-mode))
  (make-face 'font-lock-fixme-face)
  (make-face 'font-lock-error-face)
  (mapc (lambda (mode)
          (font-lock-add-keywords
           mode
           '(("\\<\\(TODO\\)" 1 'font-lock-fixme-face t)
             ("\\<\\(ERROR\\)" 1 'font-lock-error-face t))))
        fixme-modes)
  (modify-face 'font-lock-fixme-face "Red" nil nil t nil t nil nil)
  (modify-face 'font-lock-error-face "Yellow" nil nil t nil t nil nil)
#+END_SRC
** Defer loading most packages for quicker startup times
#+BEGIN_SRC emacs-lisp
  ;; (setq use-package-always-defer t)
  (setq use-package-always-demand t)
  (setq use-package-verbose t)
#+END_SRC
** Default encoding
#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
  (set-terminal-coding-system 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (set-selection-coding-system 'utf-8-unix)
  (setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC
** Completion and Minibuffer settings
#+BEGIN_SRC emacs-lisp
  (setq read-file-name-completion-ignore-case t
        completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-show-inline-help nil
        completions-detailed t
        resize-mini-windows t
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion flex))))
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+END_SRC
** Delete trailing whitespace before saving a file
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
** Create an indirect buffer with narrow view
** Dired Qol
#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
*** Create a new file from dired mode
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'dired
    '(progn
       (define-key dired-mode-map (kbd "c") 'my-dired-create-file)
       (defun create-new-file (file-list)
         (defun exsitp-untitled-x (file-list cnt)
           (while (and (car file-list) (not (string= (car file-list) (concat "untitled" (number-to-string cnt) ".txt"))))
             (setq file-list (cdr file-list)))
           (car file-list))

         (defun exsitp-untitled (file-list)
           (while (and (car file-list) (not (string= (car file-list) "untitled.txt")))
             (setq file-list (cdr file-list)))
           (car file-list))

         (if (not (exsitp-untitled file-list))
             "untitled.txt"
           (let ((cnt 2))
             (while (exsitp-untitled-x file-list cnt)
               (setq cnt (1+ cnt)))
             (concat "untitled" (number-to-string cnt) ".txt")
             )
           )
         )
       (defun my-dired-create-file (file)
         (interactive
          (list (read-file-name "Create file: " (concat (dired-current-directory) (create-new-file (directory-files (dired-current-directory))))))
          )
         (write-region "" nil (expand-file-name file) t)
         (dired-add-file file)
         (revert-buffer)
         (dired-goto-file (expand-file-name file))
         )
       )
    )
  #+END_SRC
*** Create a new window and open dired there
#+BEGIN_SRC emacs-lisp
    (defun my-display-buffer-below (buffer alist)
    "Doc-string."
      (let (
          (window
            (cond
              ((get-buffer-window buffer (selected-frame)))
              ((window-in-direction 'below))
              (t
                (split-window (selected-window) nil 'below)))))
        (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
        window))

    (defun my-display-buffer-above (buffer alist)
    "Doc-string."
      (let (
          (window
            (cond
              ((get-buffer-window buffer (selected-frame)))
              ((window-in-direction 'above))
              (t
                (split-window (selected-window) nil 'above)))))
        (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
        window))

    (defun my-display-buffer-left (buffer alist)
    "Doc-string."
      (let (
          (window
            (cond
              ((get-buffer-window buffer (selected-frame)))
              ((window-in-direction 'left))
              (t
                (split-window (selected-window) nil 'left)))))
        (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
        window))

    (defun my-display-buffer-right (buffer alist)
    "Doc-string."
      (let (
          (window
            (cond
              ((get-buffer-window buffer (selected-frame)))
              ((window-in-direction 'right))
              (t
                (split-window (selected-window) nil 'right)))))
        (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
        window))

    (defun dired-display-above ()
    "Doc-string."
    (interactive)
      (let* (
          (file-or-dir (dired-get-file-for-visit))
          (buffer (find-file-noselect file-or-dir)))
        (my-display-buffer-above buffer nil)))

    (defun dired-display-below ()
    "Doc-string."
    (interactive)
      (let* (
          (file-or-dir (dired-get-file-for-visit))
          (buffer (find-file-noselect file-or-dir)))
        (my-display-buffer-below buffer nil)))

    (defun dired-display-left ()
    "Doc-string."
    (interactive)
      (let* (
          (file-or-dir (dired-get-file-for-visit))
          (buffer (find-file-noselect file-or-dir)))
        (my-display-buffer-left buffer nil)))

    (defun dired-display-right ()
    "Doc-string."
    (interactive)
      (let* (
          (file-or-dir (dired-get-file-for-visit))
          (buffer (find-file-noselect file-or-dir)))
        (my-display-buffer-right buffer nil)))
  (define-key dired-mode-map (kbd "C-x i") 'dired-display-above)
  (define-key dired-mode-map (kbd "C-x k") 'dired-display-below)
  (define-key dired-mode-map (kbd "C-x j") 'dired-display-left)
  (define-key dired-mode-map (kbd "C-x l") 'dired-display-right)
#+END_SRC
*** Deleting dired buffer
**** Look under ibuffer
** Quickly access config.org and eval init.el
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)

  (defun eval-init-file ()
    (interactive)
    (load-file "~/.emacs.d/init.el"))
  (global-set-key (kbd "C-c r") 'eval-init-file)
#+END_SRC
** Diff Mode
#+BEGIN_SRC emacs-lisp
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  (setq diff-refine nil)
  (setq diff-font-lock-prettify nil)
  (setq diff-font-lock-syntax 'hunk-also)
#+END_SRC
** Suspend Emacs
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-z") 'ken_nc/suspend)
#+END_SRC
** General Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c z") 'remember)
  (global-set-key (kbd "C-c q") 'ken_nc/quit-emacs-dwim)
  (global-set-key (kbd "C-c t") 'ken_nc/create-tags)
  (global-set-key (kbd "M-i") 'move-text-up)
  (global-set-key (kbd "M-k") 'move-text-down)
  (global-set-key (kbd "M-RET") 'indent-new-comment-line)
  (global-set-key [mode-line C-mouse-1] 'tear-off-window)
  (global-set-key (kbd "C-c x") 'ken_nc/tear-off-window)
#+END_SRC
** CSS color coding
#+BEGIN_SRC emacs-lisp
  (defun xah-syntax-color-hex ()
    "Syntax color text of the form #ff1100 and #abc in current buffer.
  URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
  Version 2017-03-12"
    (interactive)
    (font-lock-add-keywords
     nil
     '(("#[[:xdigit:]]\\{3\\}"
        (0 (put-text-property
            (match-beginning 0)
            (match-end 0)
            'face (list :background
                        (let* (
                               (ms (match-string-no-properties 0))
                               (r (substring ms 1 2))
                               (g (substring ms 2 3))
                               (b (substring ms 3 4)))
                          (concat "#" r r g g b b))))))
       ("#[[:xdigit:]]\\{6\\}"
        (0 (put-text-property
            (match-beginning 0)
            (match-end 0)
            'face (list :background (match-string-no-properties 0)))))))
    (font-lock-flush))
  (add-hook 'prog-mode-hook 'xah-syntax-color-hex)
  (add-hook 'conf-xdefaults-mode-hook 'xah-syntax-color-hex)
#+END_SRC
** Tramp
#+BEGIN_SRC emacs-lisp
  (require 'tramp)
#+END_SRC
*** Dired sudo mode
You can also edit files in sudo mode with crux-edit-sudo
#+BEGIN_SRC emacs-lisp
  (defun sudired ()
    (interactive)
    (require 'tramp)
    (let ((dir (expand-file-name default-directory)))
      (if (string-match "^/sudo:" dir)
          (user-error "Already in sudo")
        (dired (concat "/sudo::" dir)))))
  (define-key dired-mode-map "!" 'sudired)
#+END_SRC
*** SSH editing with tramp
Others remote file editing packages use FTP to connect to the remote host and to transfer the files, TRAMP uses a remote shell connection (rlogin, telnet, ssh).
#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")
  (add-to-list 'tramp-remote-path "$HOME/.local/bin/")
#+END_SRC
** Isearch functionality
The defualt functionality of isearch is to put the cursor after the last character searched. Thats bad usability. Changed so that the cusor is moved to the beginning of the match searched.
#+BEGIN_SRC emacs-lisp
  (defun my-goto-match-beginning ()
    (when (and isearch-forward isearch-other-end (not isearch-mode-end-hook-quit))
      (goto-char isearch-other-end)))

  (defadvice isearch-exit (after my-goto-match-beginning activate)
    "Go to beginning of match."
    (when (and isearch-forward isearch-other-end)
      (goto-char isearch-other-end)))
  (add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

  (setq search-whitespace-regexp ".*"
        isearch-lax-whitespace t
        isearch-regexp-lax-whitespace nil
        isearch-lazy-highight t
        isearch-lazy-count t)

  (define-key isearch-mode-map (kbd "C-s") 'consult-line)

  ;; Display last searched string in minibuffer prompt
  ;; (add-hook 'isearch-mode-hook (lambda () (interactive)
  ;;                                (setq isearch-message (concat isearch-message "[ " (car search-ring) " ] "))
  ;;                                (isearch-search-and-update)))
#+END_SRC
** Recentf mode
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (recentf-mode 1)
    :hook
    (buffer-list-update-hook . recentf-track-opened-file))
#+END_SRC
** WGrep
WGrep allows you to edit a grep buffer and apply those changes to the file buffer like sed interactively. No need to learn sed script, just learn Emacs.
Save buffer automatically when wgrep-finish-edit
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :custom
    (wgrep-auto-save-buffer t)
    :config
    ;; Change the default key binding to switch to wgrep
    (global-set-key (kbd "C-q") 'ken_nc/edit-buffer-dwim)
    (grep-apply-setting
     'grep-template
     "--color --ignore-case --line-number --with-filename --recursive --null --perl-regexp --regexp"))
#+END_SRC
** Emacs default completion for elisp
Emacs has its own built-in functionality which enables TAB completion for elisp
#+BEGIN_SRC emacs-lisp
  (setq-local tab-always-indent 'complete)
#+END_SRC
** Setup mouse click to highlight matching words
#+BEGIN_SRC emacs-lisp
  (defun ken_nc/find-word-on-click (event)
    (interactive "e")
    (let ((word-at-point  (posn-point (event-end event))))
      (goto-char word-at-point)
      (isearch-forward-symbol-at-point)))

  (global-set-key (kbd "<mouse-3>") 'ken_nc/find-word-on-click)
#+END_SRC
** Auto Complete in IELM
#+BEGIN_SRC emacs-lisp
  (defun ielm-auto-complete ()
    "Enables `auto-complete' support in \\[ielm]."
    (setq ac-sources '(ac-source-functions
                       ac-source-variables
                       ac-source-features
                       ac-source-symbols
                       ac-source-words-in-same-mode-buffers))
    (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
    (auto-complete-mode 1))
  (add-hook 'ielm-mode-hook 'ielm-auto-complete)
#+END_SRC
** Music in emacs
#+BEGIN_SRC emacs-lisp
  (setq
   mpc-browser-tags '(Artist Album)
   mpc-songs-format "%-5{Time} %25{Title} %20{Album} %20{Artist}")
#+END_SRC
** Show number of lines and words in modeline
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'wc-mode)
  (add-hook 'prog-mode-hook 'wc-mode)
  (setq wc-modeline-format "[Words: %tw, Lines: %tl]")
#+END_SRC
** Ligature
#+BEGIN_SRC emacs-lisp

#+END_SRC
** Garbage Collection on focus-out
Garbage-collect on focus-out, Emacs should feel snappier overall.
Deprecated cause I am using GCMH
#+BEGIN_SRC emacs-lisp
  ;; (add-function :after after-focus-change-function
  ;;   (defun ken_nc/garbage-collect-maybe ()
  ;;     (unless (frame-focus-state)
  ;;       (garbage-collect))))
#+END_SRC
** Garbage Collection Magic Hack
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :ensure t
    :blackout t
    :init
    (gcmh-mode 1)
    :custom
    (gcmh-verbose t))
#+END_SRC
** Hungry-delete
*** Description
Using hungry-delete, one hit of delete-key eats the following white spaces and
new lines, or just delete one character. One hit of backspace-key eats the
preceding white spaces, or just delete one character.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :custom
    (hungry-delete-join-reluctantly t))
#+END_SRC
** Disable flymake
#+BEGIN_SRC emacs-lisp
  (flymake-mode-off)
  (remove-hook 'c-mode-hook 'flymake-mode t)
  (remove-hook 'c++-mode-hook 'flymake-mode t)
  (remove-hook 'python-mode-hook 'flymake-mode t)
#+END_SRC
** Disable auto indenting
#+BEGIN_SRC emacs-lisp
  (electric-indent-mode nil)
#+END_SRC
** Desktop Save Mode
Freeze the current state of emacs and reload later
#+BEGIN_SRC emacs-lisp
  ;; (desktop-save-mode 1)
  ;; (setq desktop-load-locked-desktop t)
#+END_SRC
* Emacs Frame Customization
#+BEGIN_SRC emacs-lisp
  (push '(width . 110) default-frame-alist)
  (push '(height . 44) default-frame-alist)
  (push '(cursor-type . 'box) default-frame-alist)
  (push '(alpha . (100 95)) default-frame-alist)
  ;; (push '(cursor-color . "white smoke") default-frame-alist)
  ;; (push '(mouse-color . "white smoke") default-frame-alist)
  ;; (push '(font . "Comic Code Ligatures:size=15") default-frame-alist)
  (push '(font . "Intel One Mono:size=15") default-frame-alist)
  (push '(alpha-background . 100) default-frame-alist)

  (setq initial-frame-alist default-frame-alist)
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (setq frame-resize-pixelwise t)
#+END_SRC
* Emacs Theme Hack
#+BEGIN_SRC emacs-lisp
  (defun load-theme--disable-old-theme (theme &rest args)
    "Disable current theme before loading new one."
    (mapcar #'disable-theme custom-enabled-themes))
  (advice-add 'load-theme :before #'load-theme--disable-old-theme)
#+END_SRC
* Emacs
Modeline
#+BEGIN_SRC emacs-lisp
  (defun mode-line-fill (reserve)
    "Return empty space using FACE and leaving RESERVE space on the right."
    (unless reserve
      (setq reserve 20))
    (when (and window-system (eq 'right (get-scroll-bar-mode)))
      (setq reserve (- reserve 3)))
    (propertize " "
                'face nil
                'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))))

  (setq-default mode-line-format
                (list "%e"
                      mode-line-front-space
                      mode-line-mule-info
                      mode-line-client
                      mode-line-modified
                      mode-line-remote
                      mode-line-frame-identification
                      mode-line-buffer-identification
                      mode-line-position
                      mode-line-modes
                      mode-line-misc-info
                      '(:eval (mode-line-fill 8))
                      '(:eval (sky-color-clock))
                      mode-line-end-spaces))
  #+END_SRC
* Org mode
** Description
One of the main selling points of Emacs! no Emacs distribution is complete without sensible and well-defined org-mode defaults
** Code
#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    (add-hook 'org-mode-hook 'org-indent-mode)
    (add-hook 'org-mode-hook
              '(lambda ()
                 (visual-line-mode 1)
                 (variable-pitch-mode 1)))
    (setq org-startup-folded t))

  (use-package org-indent-
    :blackout t)

  (set-face-attribute 'org-block nil
                      :background "#0a0a0a")
#+END_SRC
* Eshell
** Why Eshell?
We are using Emacs, so we might as well implement as many tools from our workflow into it as possible
*** Caveats
Eshell cannot handle ncurses programs and in certain interpreters (Python, GHCi) selecting previous commands does not work (for now). I recommend using eshell for light cli work, and using your external terminal emulator of choice for heavier tasks
** Settings
Both M-x shell-command and M-x compile execute commands in an inferior shell via call-process.
Change to use aliases found in login shell. Also disable internal elisp commands.
#+BEGIN_SRC emacs-lisp
  (setq shell-file-name "bash")
  ;; (setq shell-command-switch "-ic")
  (setq eshell-prefer-lisp-functions t)
#+END_SRC
** Prompt
#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-regexp "^[^λ\n]*[λ] ")
  (setq eshell-prompt-function
        (lambda nil
          (concat
           (if (string= (eshell/pwd) (getenv "HOME"))
               (propertize "~" 'face `(:foreground "#99CCFF"))
             (replace-regexp-in-string
              (getenv "HOME")
              (propertize "~" 'face `(:foreground "#99CCFF"))
              (propertize (eshell/pwd) 'face `(:foreground "#99CCFF"))))
           (if (= (user-uid) 0)
               (propertize " α " 'face `(:foreground "#FF6666"))
             (propertize " λ " 'face `(:foreground "#A6E22E"))))))

  (setq eshell-highlight-prompt nil)
#+END_SRC
** Aliases
#+BEGIN_SRC emacs-lisp
  (defalias 'open 'find-file-other-window)
  (defalias 'clean 'eshell/clear-scrollback)
#+END_SRC
** Custom functions
*** Open files as root
#+BEGIN_SRC emacs-lisp
  (defun eshell/sudo-open (filename)
    "Open a file as root in Eshell."
    (let ((qual-filename (if (string-match "^/" filename)
                             filename
                           (concat (expand-file-name (eshell/pwd)) "/" filename))))
      (switch-to-buffer
       (find-file-noselect
        (concat "/sudo::" qual-filename)))))
#+END_SRC
*** Control - Shift - RET to open eshell
#+BEGIN_SRC emacs-lisp
  (defun eshell-other-window ()
    "Create or visit an eshell buffer."
    (interactive)
    (if (not (get-buffer "*eshell*"))
        (progn
          (split-window-sensibly (selected-window))
          (other-window 1)
          (eshell))
      (switch-to-buffer-other-window "*eshell*")))

  (global-set-key (kbd "<C-S-return>") 'eshell)
#+END_SRC
*** Parse Bash History
#+BEGIN_SRC emacs-lisp
  ;; (ken_nc/parse-bash-history)
#+END_SRC
* Use-package section
** Initialize =auto-package-update=
*** Description
Auto-package-update automatically updates and removes old packages
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :config
    (setq auto-package-update-delete-old-versions t)
    (setq auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+END_SRC
** Initialize =which-key=
*** Description
Incredibly useful package; if you are in the middle of a command and don't know what to type next, just wait a second and you'll get a nice buffer with all possible completions
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :blackout t
    :init
    (which-key-mode))
#+END_SRC
** Initialize =diminish=
*** Description
Diminish hides minor modes to prevent cluttering your mode line
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC
** Initialize =dashboard=
*** Description
The frontend of Witchmacs; without this there'd be no Marisa in your Emacs startup screen
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :preface
    (defun update-config ()
      "Update Witchmacs to the latest version."
      (interactive)
      (let ((dir (expand-file-name user-emacs-directory)))
        (if (file-exists-p dir)
            (progn
              (message "Marisa is updating!")
              (cd dir)
              (shell-command "git pull")
              (message "Update finished. Switch to the messages buffer to see changes and then restart Emacs"))
          (message "\"%s\" doesn't exist." dir))))

    (defun create-scratch-buffer ()
      "Create a scratch buffer"
      (interactive)
      (switch-to-buffer (get-buffer-create "*scratch*"))
      (lisp-interaction-mode))
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-items '((recents . 5)))
    (setq dashboard-banner-logo-title "M A R I S A - Connect To The Wired Edition!")
    ;; (setq dashboard-startup-banner "~/.emacs.d/lain.png")
    ;; (setq dashboard-startup-banner "~/.emacs.d/athos_monk_emacs.png")
    ;; (setq dashboard-startup-banner "~/.emacs.d/xemacs_color.svg")
    (setq dashboard-startup-banner "~/.emacs.d/VtuberEmacsLogo.png")
    (setq dashboard-center-content t)
    (setq dashboard-show-shortcuts nil)
    (setq dashboard-set-init-info t)
    (setq dashboard-init-info (format "%d packages loaded in %s"
                                      (length package-activated-list) (emacs-init-time)))
    (setq dashboard-set-footer nil)
    (setq dashboard-set-navigator t)
    (setq dashboard-navigator-buttons
          `(;; line1
            ((,nil
              "Witchmacs on github"
              "Open Marisa on github"
              (lambda (&rest _) (browse-url "https://github.com/GrapeJuiceSoda/marisa"))
              'default)
             (nil
              "Witchmacs crash course"
              "Open Witchmacs' introduction to Emacs"
              (lambda (&rest _) (find-file "~/.emacs.d/Witcheat.org"))
              'default)
             (nil
              "Update Witchmacs"
              "Get the latest Witchmacs update. Check out the github commits for changes!"
              (lambda (&rest _) (update-config))
              'default)
             )
            ;; line 2
            ((,nil
              "Open scratch buffer"
              "Switch to the scratch buffer"
              (lambda (&rest _) (create-scratch-buffer))
              'default)
             (nil
              "Open config.org"
              "Open Marisa' configuration file for easy editing"
              (lambda (&rest _) (find-file "~/.emacs.d/config.org"))
              'default)))))
#+END_SRC
*** Notes
If you pay close attention to the code in dashboard, you'll  notice that it uses custom functions defined under the :preface use-package block. I wrote all of those functions by looking at other people's Emacs distributions (Mainly [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]]) and then experimenting and adapting them to Witchmacs. If you dig around, you'll find the same things I did - maybe even more!
*** Historical
22/05/19: On this day, the main maintainers of the dashboard package have added built-in fuinctionality to display init and package load time, thing that I already had implemented much earlier on my own. I have left here my implementation for historical purposes
#+BEGIN_SRC emacs-lisp
  ;(insert (concat
  ;         (propertize (format "%d packages loaded in %s"
  ;                             (length package-activated-list) (emacs-init-time))
  ;                     'face 'font-lock-comment-face)))
  ;
  ;(dashboard-center-line)
#+END_SRC
** Initialize =beacon=
*** Description
You might find beacon an unnecesary package but I find it very neat. It briefly highlights the cursor position when switching to a new window or buffer
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :blackout t
    :init
    (beacon-mode -1))
#+END_SRC
** Initialize =htmlize=
*** Description
Highligh rgb and hex values with the color associated with them
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t
    :defer t)
#+END_SRC
** Initialize =mozc=
*** 日本語入力
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package mozc
    :ensure t
    :defer t)
#+END_SRC
** Initialize =ido= and =ido-vertical=
*** Description
For the longest time I used the default way of switching and killing buffers in Emacs. Same for finding files. Ido-mode made these three tasks IMMENSELY easier and more intuitive. Please not that I still use the default way M - x works because I believe all you really need for it is which-key
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :defer t
    ;; :init (ido-mode 1)
    :config
    (setq ido-enable-flex-matching nil)
    (setq ido-create-new-buffer 'prompt)
    (setq ido-everywhere nil))

  (use-package ido-vertical-mode
    :ensure t
    :defer t
    :after ido
    :init
    (ido-vertical-mode 1)
    :custom
    ;; This enables arrow keys to select while in ido mode. If you want to
    ;; instead use the default Emacs keybindings, change it to
    ;; "'C-n-and-C-p-only"
    (ido-vertical-define-keys 'C-n-C-p-up-and-down))

#+END_SRC
** Initialize =async=
*** Description
Utilize asynchronous processes whenever possible
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package async
	:ensure t
	:init
	(dired-async-mode 1))
#+END_SRC
** Initialize =page-break-lines=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :ensure t
    :blackout t)
#+END_SRC
** Initialize =crux=
*** Description
A Collection of Ridiculously Useful eXtensions for Emac
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t)
#+END_SRC
** Initialize =amx=
*** Description
Amx is an alternative interface for M-x in Emacs. It provides several
enhancements over the ordinary execute-extended-command, such as prioritizing
your most-used commands in the completion list and showing keyboard shortcuts,
and it supports several completion systems for selecting commands, such as ido
and ivy.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package amx
    :ensure t)
#+END_SRC
** Initialize =dired-toggle-sudo=
*** Code
Allow to switch from current user to sudo when browsind `dired' buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dired-toggle-sudo
    :ensure t
    :defer t)
#+END_SRC
** Initialize =magit=
*** Description
Git porcelain for Emacs
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC
** Initialize =expand-region=
*** Description
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    ;; :bind ("<mouse-2>" . er/expand-region)
    )
#+END_SRC
** Initialize =highlight=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package highlight
    :ensure t)
#+END_SRC
** Initialize =ag=
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t
    :config
    (setq ag-highlight-search t)
    (setq ag-executable "/usr/bin/ag")
    (setq ag-reuse-buffers t))
#+END_SRC
** Initialize =blackout=
*** Description
Blackout is a package which allows you to hide or customize the display of major and minor modes in the mode line.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package blackout
    :ensure t
    :config
    (with-eval-after-load 'xah-fly-keys
      (blackout 'xah-fly-keys))
    (with-eval-after-load 'undo-hl
      (blackout 'undo-hl-mode))
    (blackout 'highlight-changes-mode)
    (blackout 'auto-revert-mode)
    (blackout 'buffer-face-mode)
    (blackout 'flymake-mode)
    (blackout 'visual-line-mode))
#+END_SRC
** Initialize =dimmer=
*** Description
This package provides a minor mode that indicates which buffer is currently active by dimming the faces in the other buffers. It does this nondestructively, and computes the dimmed faces dynamically such that your overall color scheme is shown in a muted form without requiring you to define what is a "dim" version of every face.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package dimmer
    :ensure t
    :blackout t
    :custom
    (dimmer-fraction 0.6)
    :config
    (add-to-list 'dimmer-buffer-exclusion-regexps "diff")
    (dimmer-mode -1)
    (dimmer-configure-magit)
    (dimmer-configure-which-key)
    (dimmer-configure-company-box))
#+END_SRC
** Initialize =zoom=
*** Description
This minor mode takes care of managing the window sizes by enforcing a fixed and automatic balanced layout where the currently selected window is resized according to zoom-size which can be an absolute value in lines/columns, a ratio between the selected window and frame size or even a custom callback.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package zoom
    :ensure t
    :blackout t
    :custom
    (zoom-mode nil)
    (zoom-size '(0.618 . 0.618))
    (zoom-ignored-major-modes '(dired-mode magit-mode eshell-mode)))
#+END_SRC
** Initialize =ligature=
#+BEGIN_SRC emacs-lisp
  (use-package ligature
    :ensure t
    :hook
    (prog-mode . ligature-mode)
    :config
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://")))
#+END_SRC
** Initialize =company-ctags=
#+BEGIN_SRC emacs-lisp
  (use-package company-ctags
    :load-path "lisp/company-ctags"
    :commands (company-ctags))
#+END_SRC
** Initialize =projectile=
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :blackout t
    :init
    (projectile-mode 1)
    :custom
    (projectile-indexing-method 'alien)
    (projectile-enable-caching t)
    (projectile-completion-system 'default))
#+END_SRC
** Initialize =sky-color-clock=
#+BEGIN_SRC emacs-lisp
  (sky-color-clock-initialize 38)  ;; california
  (setq sky-color-clock-format "%H:%M")
  (setq sky-color-clock-enable-emoji-icon nil)
#+END_SRC
** Initialize =pulsar=
*** Description
Pulse highlight line on demand or after running select functions
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package pulsar
    :ensure t
    :blackout t
    :hook
    (next-error-hook . pulsar-pulse-line)
    (find-file-hook . pulsar-pulse-line)
    (consult-after-jump-hook . pulsar-recenter-top)
    (consult-after-jump-hook . pulsar-reveal-entry)
    :init
    (pulsar-global-mode 1)
    :custom
    (pulsar-pulse-on-window-change t)
    (pulsar-pulse t)
    (pulsar-delay 0.055)
    (pulsar-iterations 10)
    (pulsar-face 'pulsar-cyan))
#+END_SRC
** Initialize =diff-hl=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :blackout t
    :init
    (global-diff-hl-mode))
#+END_SRC
** Initialize =git timemachine=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t
    :defer t
    :bind
    (:map git-timemachine-mode-map
          ("j" . git-timemachine-show-previous-revision)
          ("l". git-timemachine-show-next-revision))
    :hook
    (git-timemachine-mode . xah-fly-mode-toggle)
    :custom
    (git-timemachine-show-minibuffer-details t))
#+END_SRC
** Initialize =embark=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :ensure t
    :bind
    (("C-c a" . embark-export))
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    (setq embark-indicators
          '(embark-minimal-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator)
          prefix-help-command #'embark-prefix-help-command
          embark-prompter #'embark-completing-read-prompter))

  (use-package embark-consult
    :ensure t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC
** Initialize =vertico=
*** Description
Vertico provides a performant and minimalistic vertical completion UI based on
the default completion system. The main focus of Vertico is to provide a UI
which behaves correctly under all circumstances.
*** Code
#+BEGIN_SRC emacs-lisp
  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode)
    :config
    (add-to-list 'savehist-additional-variables 'command-history 'kill-ring)
    (setq
     history-delete-duplicates t
     history-length t
     savehist-file "~/.emacs.d/history"))

  (use-package vertico
    :ensure t
    :after minibuffer consult
    :init (vertico-mode 1)
    :bind
    (:map vertico-map
          ("TAB" . minibuffer-complete)
          ("M-v" . vertico-multiform-vertical)
          ("M-g" . vertico-multiform-grid)
          ("M-f" . vertico-multiform-flat)
          ("M-r" . vertico-multiform-reverse)
          ("M-u" . vertico-multiform-unobtrusive)
          ("M-q" . vertico-quick-insert)
          ("C-q" . vertico-quick-exit)
          ("?" . minibuffer-completion-help)
          ("M-RET" . minibuffer-force-complete-and-exit))
    :custom
    (vertico-scroll-margin 0)
    (vertico-count 20)
    (vertico-resize t)
    (vertico-cycle t)
    :config
    (consult-customize
     consult-line
     :add-history (seq-some #'thing-at-point '(region symbol)))
    (defalias 'consult-line-thing-at-point 'consult-line)

    (consult-customize
     consult-line-thing-at-point
     :initial (thing-at-point 'symbol)))

  (use-package vertico-multiform
    :commands vertico-multiform-mode
    :after vertico
    :init
    (vertico-multiform-mode 1)
    :config
    (setq vertico-multiform-commands
          '((load-theme reverse)
            (consult-history reverse mouse)
            (consult-flycheck mouse)
            (consult-recent-file reverse mouse)))

    (setq vertico-multiform-categories
          '((file reverse mouse)
            (project-file grid reverse)
            (location buffer)
            (grep buffer)
            (buffer flat (vertico-cycle . t))
            (xref-location reverse)
            (history reverse mouse)
            (consult-compile-error reverse))))

  (use-package vertico-buffer
    :after vertico
    :config
    (setq vertico-buffer-display-action 'display-buffer-reuse-window))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 5)

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)
    (setq enable-recursive-minibuffers t))
#+END_SRC
** Initialize =cape=
*** Description
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package cape
    :ensure t
    :init
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-symbol))

  ;; Shell completion
  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
#+END_SRC
** Initialize =iedit=
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :init)
#+END_SRC
** Initialize =undohist=
#+BEGIN_SRC emacs-lisp
  (use-package undohist
    :ensure t
    :init
    (undohist-initialize))
#+END_SRC
** Initialize =popwin=
#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :ensure t
    :init
    (popwin-mode 1)
    :config
    (push '("*ag search*" :dedicated t :stick t) popwin:special-display-config)
    (push '("*xref*" :dedicated t :stick t) popwin:special-display-config)
    (push '("*Occur*" :dedicated t :stick t) popwin:special-display-config)
    (push '("*eshell*" :dedicated t :stick t) popwin:special-display-config)
    (push '("*eldoc*" :noselect t :position bottom) popwin:special-display-config)
    (push '("*Ibuffer*" :dedicated t :stick t) popwin:special-display-config)
    (push '("*compilation*" :dedicated t :stick t) popwin:special-display-config)
    (push '(compilation-mode :noselect t :tail t) popwin:special-display-config)
    (push "*vc-diff*" popwin:special-display-config)
    (push "*vc-change-log*" popwin:special-display-config)
    (push '("magit.*" :regexp t :stick t) popwin:special-display-config)
    (push '("Embark Collect:.*" :regexp t :stick t) popwin:special-display-config))
#+END_SRC
** Initialize =wrap-region=
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :ensure t
    :blackout t
    :config
    (wrap-region-add-wrappers
     '(("<" ">")
       ("'" "'")
       ("[" "]")
       ("{" "}")
       ("/* " " */" "#" (java-mode c-mode css-mode go-mode)))))
#+END_SRC
** Initialize =exec-path-from-shell=
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    ;; add environment variables to emacs environment
    (dolist (var '("BROWSER" "PLAN9" "COLORTERM" "XTERM_VERSION" "TERM"))
      (add-to-list 'exec-path-from-shell-variables var))
    (exec-path-from-shell-initialize))
#+END_SRC
** Initialize =consult=
*** Description
Consult provides practical commands based on the Emacs completion function
completing-read.
*** Code
#+BEGIN_SRC emacs-lisp
    (use-package consult
      :ensure t
      :init
      :custom
      (consult--grep-regexp-type 'pcre)
      (consult-async-min-input 3)
      (xref-show-xrefs-function #'consult-xref)
      (xref-show-definitions-function #'consult-xref))

    (use-package consult-yasnippet
      :ensure t
      :after consult)

    (use-package consult-ag
      :ensure t
      :after consult)
#+END_SRC
** Initialize =marginalia=
*** Description
This package provides marginalia-mode which adds marginalia to the minibuffer
completions. Marginalia are marks or annotations placed at the margin of the
page of a book or in this case helpful colorful annotations placed at the margin
of the minibuffer for your completion candidates.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :ensure t
    ;; Either bind `marginalia-cycle' globally or only in the minibuffer
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
    #+END_SRC
** Initialize =smart-hungry-delete=
#+BEGIN_SRC emacs-lisp
  (use-package smart-hungry-delete
    :ensure t
    :bind (:map prog-mode-map
                ([remap backward-delete-char-untabify] . smart-hungry-delete-backward-char)
                ([remap delete-backward-char] . smart-hungry-delete-backward-char)
                ([remap delete-char] . smart-hungry-delete-forward-char))
    :init (smart-hungry-delete-add-default-hooks))
#+END_SRC
** Initialize =orderless=
*** Description
This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order.
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :ensure t
    :demand t
    :config
    ;; https://github.com/minad/consult/wiki#use-orderless-as-pattern-compiler-for-consult-grepripgrepfind
    (defun consult--orderless-regexp-compiler (input type &rest _config)
      (setq input (orderless-pattern-compiler input))
      (cons
       (mapcar (lambda (r) (consult--convert-regexp r type)) input)
       (lambda (str) (orderless--highlight input t str))))

    (setq consult--regexp-compiler #'consult--orderless-regexp-compiler
          consult--grep-regexp-type 'pcre
          orderless-component-separator #'orderless-escapable-split-on-space
          completion-category-defaults nil
          completion-category-overrides nil)

    (add-to-list 'completion-category-overrides
                 '(file (styles partial-completion))))

#+END_SRC
** Initialize =affe=
*** Description
Fuzzy matching for find-file
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package affe
    :ensure t
    :config
    (defun affe-orderless-regexp-compiler (input _type _ignorecase)
      (setq input (orderless-pattern-compiler input))
      (cons input (apply-partially #'orderless--highlight input)))
    (setq affe-regexp-compiler #'affe-orderless-regexp-compiler))
#+END_SRC
** Initialize =fussy=
*** Description
This is a package to provide a completion-style to Emacs that is able to
leverage flx as well as various other fuzzy matching scoring packages to provide
intelligent scoring and sorting.

Fuzzy matching for company eglot completion
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package hotfuzz
    :ensure t
    :init
    :config
    (setq fussy-score-fn 'fussy-hotfuzz-score))

  (use-package fussy
    :ensure t
    :after hotfuzz
    :config
    (setq
     ;; For example, project-find-file uses 'project-files which uses
     ;; substring completion by default. Set to nil to make sure it's using
     ;; flx.

     fussy-filter-fn 'fussy-filter-orderless-flex)

    (with-eval-after-load 'eglot
      (add-to-list 'completion-category-overrides
                   '(eglot (styles fussy basic))))

    (defun bb-company-capf (f &rest args)
      "Manage `completion-styles'."
      (if (length< company-prefix 2)
          (let ((completion-styles (remq 'fussy completion-styles)))
            (apply f args))
        (let ((fussy-max-candidate-limit 5000)
              (fussy-default-regex-fn 'fussy-pattern-first-letter)
              (fussy-prefer-prefix nil))
          (apply f args))))

    (defun bb-company-transformers (f &rest args)
      "Manage `company-transformers'."
      (if (length< company-prefix 2)
          (apply f args)
        (let ((company-transformers '(fussy-company-sort-by-completion-score)))
          (apply f args))))

    (advice-add 'company-auto-begin :before 'fussy-wipe-cache)
    (advice-add 'company--transform-candidates :around 'bb-company-transformers)
    (advice-add 'company-capf :around 'bb-company-capf))

#+END_SRC
** Initialize =color identifiers=
*** Description
Color Identifiers is a minor mode for Emacs that highlights each source code identifier uniquely based on its name
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package color-identifiers-mode
    :ensure t
    :blackout t
    :custom
    (color-identifiers:recoloring-delay 1)
    :config
    (defun myfunc-color-identifiers-mode-hook ()
      (let ((faces '(font-lock-comment-face font-lock-comment-delimiter-face font-lock-constant-face font-lock-type-face font-lock-function-name-face font-lock-variable-name-face font-lock-keyword-face font-lock-string-face font-lock-builtin-face font-lock-preprocessor-face font-lock-warning-face font-lock-doc-face font-lock-negation-char-face font-lock-regexp-grouping-construct font-lock-regexp-grouping-backslash)))
        (dolist (face faces)
          (face-remap-add-relative face '(:inherit default))))
      (face-remap-add-relative 'font-lock-keyword-face '((:weight bold)))
      (face-remap-add-relative 'font-lock-comment-face '((:slant italic)))
      (face-remap-add-relative 'font-lock-builtin-face '((:weight bold)))
      (face-remap-add-relative 'font-lock-preprocessor-face '((:weight bold)))
      (face-remap-add-relative 'font-lock-function-name-face '((:slant italic)))
      (face-remap-add-relative 'font-lock-string-face '((:slant italic)))
      (face-remap-add-relative 'font-lock-constant-face '((:weight bold))))
    :hook
    ;; (color-identifiers-mode . myfunc-color-identifiers-mode-hook)
    (c-mode . color-identifiers-mode)
    (c++-mode . color-identifiers-mode))
#+END_SRC
** Built-in entry: =eldoc=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :blackout t)
#+END_SRC
** Built-in entry: =abbrev=
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package abbrev
    :blackout t)
#+END_SRC
** Built-in entry: =tree-sitter=
#+BEGIN_SRC emacs-lisp
  (setq treesit-language-source-alist
        '((cpp "https://github.com/tree-sitter/tree-sitter-cpp")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (rust "https://github.com/tree-sitter/tree-sitter-rust")
          (java "https://github.com/tree-sitter/tree-sitter-java")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (ocaml "https://github.com/tree-sitter/tree-sitter-ocaml")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (bash "https://github.com/tree-sitter/tree-sitter-bash")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (make "https://github.com/alemuller/tree-sitter-make")
          (cmake "https://github.com/uyha/tree-sitter-cmake")))

  (customize-set-variable 'treesit-font-lock-level 4)
#+END_SRC
* Programming section
** Initialize =emacs=
*** Description
Some emacs settings that are useful for completions
*** Code
#+BEGIN_SRC emacs-lisp
  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 5)

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)
    (setq enable-recursive-minibuffers t)
    :config
    (setq completion-styles '(hotfuzz orderless substring fussy basic)))
#+END_SRC
** Initialize fancy-compilation
#+BEGIN_SRC emacs-lisp
  (use-package fancy-compilation
    :ensure t
    :blackout t
    :custom
    (fancy-compilation-quiet-prelude t)
    (fancy-compilation-term "xterm-color")
    :config
    (fancy-compilation-mode t))
#+END_SRC
** Initialize =company=
#+BEGIN_SRC emacs-lisp
  (defun just-one-face (fn &rest args)
    (let ((orderless-match-faces [completions-common-part]))
      (apply fn args)))

  (use-package company
    :ensure t
    :demand t
    :blackout t
    :bind
    (:map company-mode-map
          ("<tab>" . company-indent-or-complete-common)
          ("TAB" . company-indent-or-complete-common)
          :map company-active-map
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous)
          ("SPC" . company-abort))
    :config
    (setq company-idle-delay nil
          company-minimum-prefix-length 3
          company-ctags-ignore-case t
          company-ctags-fuzzy-match-p t
          company-dabbrev-downcase nil
          company-dabbrev-other-buffers nil
          company-dabbrev-ignore-case nil
          completion-ignore-case t
          company-backends '((company-capf :with company-yasnippet :with company-files) (company-ctags)))
    (advice-add 'company-capf--candidates :around #'just-one-face))

  (use-package company-quickhelp
    :ensure t
    :after company
    :hook (company-mode . company-quickhelp-mode)
    :config
    (setq company-quickhelp-delay 1))
#+END_SRC
** Initialize =aggressive-indent-mode=
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
    ;; (add-hook 'c-mode-hook #'aggressive-indent-mode)
    ;; (add-hook 'c++-mode-hook #'aggressive-indent-mode)
    (add-to-list
     'aggressive-indent-dont-indent-if
     '(and (derived-mode-p 'c-mode)
           (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                               (thing-at-point 'line))))))
#+END_SRC
** Initialize =dumb-jump=
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :custom
    (dumb-jump-git-grep-search-args "")
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    ;; only force dumb-jump to use ripgrep if it exists on system
    (when (executable-find "rg")
      (progn
        (setq dumb-jump-force-searcher 'rg)
        (setq dumb-jump-prefer-searcher 'rg)
        (setq dumb-jump-ag-search-args ""))))
#+END_SRC
** Initialize =eglot=
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :ensure t
    :blackout t
    :custom
    (eglot-autoshutdown t)
    (eglot-extend-to-xref t)
    (eglot-sync-connect 0)
    (eglot-events-buffer-size 0)
    :config
    (advice-add 'jsonrpc--log-event :override #'ignore)

    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs
                   '((c-mode c++-mode)
                     . ("clangd"
                        "--enable-config"
                        "-j=4"
                        "--function-arg-placeholders=false"
                        "--all-scopes-completion"
                        "--log=info"
                        "--malloc-trim"
                        "--background-index"
                        "--clang-tidy"
                        "--query-driver=/usr/bin/g++,/usr/bin/clang++"
                        "--completion-style=bundled"
                        "--suggest-missing-includes"
                        "--pch-storage=memory"
                        "--header-insertion=iwyu"
                        "--header-insertion-decorators=0"))))
    (setq eglot-autoshutdown t)
    (define-key eglot-mode-map (kbd "C-c r") 'eglot-rename)
    (define-key eglot-mode-map (kbd "C-c o") 'eglot-code-action-organize-imports)
    (define-key eglot-mode-map (kbd "C-c h") 'eldoc))

  ;; disable eldoc
  (add-hook 'eglot-managed-mode-hook (lambda () (eldoc-mode -1)))
  (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1)))
#+END_SRC
** Initialize =yasnippet=
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets
    :ensure t)

  (use-package yasnippet
    :ensure t
    ;; :blackout yas-minor-mode
    :hook
    (prog-mode-hook . yas-minor-mode)
    :init
    (yas-global-mode t)
    (yas-reload-all)
    :config
    (setq yas-snippet-dirs
          '("~/.emacs.d/snippets")))
#+END_SRC
** Initialize =flycheck=
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :blackout t)
#+END_SRC
** C & C++
*** Description
Irony is the company backend for C and C++
*** Code
#+BEGIN_SRC emacs-lisp
  (defun c-mode-variables ()
    (setq-local tab-width 4)
    (setq-local flycheck-gcc-language-standard "gnu17")
    (setq-local flycheck-clang-language-standard "gnu17"))

  (defun c++-mode-variables ()
    (setq-local tab-width 2)
    (setq-local flycheck-gcc-language-standard "c++20")
    (setq-local flycheck-clang-language-standard "c++20"))

  (use-package cc-mode
    :hook
    (c-mode . company-mode)
    (c-mode . eglot-ensure)
    (c-mode . undo-hl-mode)
    (c-mode . wrap-region-mode)
    (c-mode . which-function-mode)
    (c-mode . flycheck-mode)
    (c-mode . c-mode-variables)

    (c++-mode . company-mode)
    (c++-mode . eglot-ensure)
    (c++-mode . undo-hl-mode)
    (c++-mode . wrap-region-mode)
    (c++-mode . which-function-mode)
    (c++-mode . flycheck-mode)
    (c++-mode . c++-mode-variables))
#+END_SRC
** Rust
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package rustic
    :ensure t
    :blackout t
    :hook
    (rustic-mode . company-mode)
    (rustic-mode . flycheck-mode)
    (rustic-mode . eglot-ensure)
    (rustic-mode . eglot-format-buffer-on-save)
    (rustic-mode . undo-hl-mode)
    (rustic-mode . wrap-region-mode)
    :custom
    (rustic-lsp-client 'eglot)
    (rustic-analyzer-command '("rustup" "run" "stable" "rust-analyzer"))
    (rust-format-on-save t))
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :defer t
    :ensure t
    :hook
    (go-mode . company-mode)
    (go-mode . eglot-ensure)
    (go-mode . eglot-format-buffer-on-save)
    (go-mode . undo-hl-mode)
    (go-mode . wrap-region-mode))

  (defun project-find-go-module (dir)
    (when-let ((root (locate-dominating-file dir "go.mod")))
      (cons 'go-module root)))

  (cl-defmethod project-root ((project (head go-module)))
    (cdr project))

  (defun eglot-format-buffer-on-save ()
    (add-hook 'before-save-hook #'eglot-format-buffer -10 t))

  (setq-default eglot-workspace-configuration
                '((:gopls .
                          ((staticcheck . t)
                           (matcher . "CaseSensitive")))))

  (add-hook 'project-find-functions #'project-find-go-module)
#+END_SRC
** Java
*** Description
Also added google-java-format
*** Code
#+BEGIN_SRC emacs-lisp
  (defun ken_nc/java-format-on-save ()
    (when (eq major-mode 'java-mode)
      (let ((prev-pos (point)))
        (call-interactively 'google-java-format-buffer)
        (goto-char prev-pos))))


  (use-package java-mode
    :hook
    (before-save-hook . ken_nc/java-format-on-save)
    (java-mode-hook . company-mode)
    (java-mode-hook . google-set-c-style)
    (java-mode-hook . eglot-ensure))
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
  ;; Probably need to install abunch of pip packages
  (use-package pyvenv
    :ensure t
    :init
    (setenv "~/.venvs/")
    :config
    ;; (pyvenv-mode t)
    (setq pyvenv-post-activate-hooks
          (list (lambda ()
                  (setq python-shell-interpreter (concat pyvenv-virtual-env "bin/python")))))

    (setq pyvenv-post-deactivate-hooks
          (list (lambda ()
                  (setq python-shell-interpreter "python3.10")))))

  (use-package blacken
    :ensure t
    :config
    (setq-default blacken-allow-p36 t)
    (setq-default blacken-fast-unsafe t)
    (setq-default blacken-line-length 120)
    (setq-default blacken-skip-string-normalization t))

  (defun ken_nc/python-format-on-save ()
    (when (eq major-mode 'python-mode)
      (let ((prev-pos (point)))
        (call-interactively 'blacken-buffer)
        (goto-char prev-pos))))

  ;; (add-hook 'before-save-hook #'ken_nc/python-format-on-save)

  (use-package python-mode
    :ensure t
    :custom
    (python-shell-interpreter "python3")
    :hook
    (python-mode . pyvenv-mode)
    (python-mode . flycheck-mode)
    (python-mode . company-mode)
    (python-mode . blacken-mode)
    (python-mode . eglot-ensure))
#+END_SRC
** Json
#+BEGIN_SRC emacs-lisp
  (defun ken_nc/json-pretty-print-on-save ()
    (when (string= (file-name-extension buffer-file-name) "json")
      (progn
        (json-pretty-print-buffer-ordered)
        (untabify (point-min) (point-max)))))

  (add-hook 'before-save-hook #'ken_nc/json-pretty-print-on-save)
#+END_SRC
** Elisp
*** Description
Company setup for emacs
*** Code
#+BEGIN_SRC emacs-lisp
  (defun ken_nc/elisp-base ()
    "Common configuration for elisp mode."
    ;; Company mode
    (with-eval-after-load 'company
      (setf company-backends '())
      (add-to-list 'company-backends 'company-ispell)
      (add-to-list 'company-backends 'company-files)
      (add-to-list 'company-backends '(company-capf :with company-dabbrev-code))
      (local-set-key (kbd "<tab>") #'company-indent-or-complete-common)))

  ;; Change a few indenting behaviors
  (put 'add-function 'lisp-indent-function 2)
  (put 'advice-add 'lisp-indent-function 2)
  (put 'plist-put 'lisp-indent-function 2)

  (add-hook 'emacs-lisp-mode-hook 'company-mode)
  (add-hook 'emacs-lisp-mode-hook #'ken_nc/elisp-base)
#+END_SRC
** Scheme =geiser-mit=
*** Description
Collection of Emacs major and minor modes that work with scheme
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package geiser-guile
    :defer t
    :ensure t
    :hook
    (geiser-mode . company-mode)
    :config
    (add-hook 'geiser-mode-hook
              (lambda ()
                (local-set-key (kbd "C-c C-b") 'geiser-eval-buffer-and-go)
                (local-set-key (kbd "C-x C-e") 'geiser-eval-definition)
                (local-set-key (kbd "C-x C-w") 'geiser-eval-definition-go))))
#+END_SRC
** Ocaml
*** Description
Help editing OCaml code, to highlight important parts of the code, to run an OCaml REPL
*** Code
#+BEGIN_SRC emacs-lisp
  (use-package tuareg
    :ensure t
    :defer t
    :bind
    (:map tuareg-mode-map
          ("<M-;>" . tuareg-comment-dwim))
    :hook
    (tuareg-mode . company-mode)
    (tuareg-mode . eglot-ensure)
    (tuareg-mode . undo-hl-mode)
    (tuareg-mode . wrap-region-mode)
    :config
    (setq tuareg-comment-show-paren t)
    (setq tuareg-highlight-all-operators t)
    (add-hook 'tuareg-mode-hook
              (lambda()
                (setq-local comment-style 'multi-line)
                (setq-local comment-continue "   "))))

  ;; (when (functionp 'prettify-symbols-mode)
  ;;   (prettify-symbols-mode))
#+END_SRC
** Highlight changes
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook #'highlight-changes-mode)
  (add-hook 'after-save-hook
            (lambda ()
              (when (highlight-changes-mode)
                (save-restriction
                  (widen)
                  (highlight-changes-remove-highlight (point-min) (point-max))))))
#+END_SRC
** Comment (mode?)
#+BEGIN_SRC emacs-lisp
  (defun ken_nc/automatic-commenting ()
    (setq-local comment-auto-fill-only-comments t)
    (setq-local auto-fill-mode t))
  (add-hook 'prog-mode-hook 'ken_nc/automatic-commenting)
#+END_SRC
** pcmpl-args
#+BEGIN_SRC emacs-lisp
  (use-package pcmpl-args
    :ensure t)
#+END_SRC
